<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cmake教程]]></title>
    <url>%2F2017%2F10%2F12%2Fcmake%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始：介绍和安装cmake是跨平台的编译构建工具，通过开发者编写CMakeList.txt文件来定制编译，然后开发者调用cmake命令就可以一步生成Makefile文件(也支持是工程文件)，如unix的Makefile或者windows的vs工程。 安装1234$ wget --no-check-certificate https://cmake.org/files/v3.9/cmake-3.9.4.tar.gz$ tar -zxvf cmake-3.9.4.tar.gz$ cd cmake-3.9.4$ ./bootstrap &amp;&amp; make &amp;&amp; make install 基本使用流程： 编写CMake 配置文件 CMakeLists.txt 执行命令cmake $PATH生成Makefile 使用make命令编译 一. 基本点最简单的项目是直接从源代码文件构建一个可执行文件，只需要在CMakeLists.txt中几行代码就可以完成。如下所示： 123456# cmake 最低版本cmake_minimum_required (VERSION 2.6)# 项目名project (Tutorial)# 添加可执行文件Tutorial以及源代码文件tutorial.cxxadd_executable(Tutorial tutorial.cxx) 添加版本号和配置文件给我们的可执行文件添加版本号，当然我们可以直接在源代码文件中来实现，但是通过CMakeLists.txt中实现会更加灵活。 第一步：我们需要按如下方式修改CMakeLists.txt文件来添加版本号1234567891011121314151617cmake_minimum_required (VERSION 2.6)project (Tutorial)# 版本号信息set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# 定义一个头文件将CMake配置信息通过头文件传给源代码configure_file ( "$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in" "$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h" )# 在include目录中添加$&#123;PROJECT_BINARY_DIR&#125;（相当于-I参数）, 使得可以找到TutorialConfig.hinclude_directories("$&#123;PROJECT_BINARY_DIR&#125;")# 添加可执行文件add_executable(Tutorial tutorial.cxx) 第二步：我们需要创建一个TutorialConfig.h.in文件在源代码目录下，内容如下：123// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 第三步：当我们在CMakeLists.txt中通过代码set (Tutorial_VERSION_MAJOR 1)和set (Tutorial_VERSION_MINOR 0)修改Tutorial_VERSION_MAJOR和 Tutorial_VERSION_MINOR这两个变量，调用cmake命令就会生成新的TutorialConfig.h文件，而不用修改源代码。代码示例：12345678910111213141516171819202122232425// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include "TutorialConfig.h"int main (int argc, char *argv[])&#123; if (argc &lt; 2) &#123; # 注意这里输出格式Tutorial_VERSION_MAJOR和Tutorial_VERSION_MINOR是int型 fprintf(stdout,"%s Version %d.%d\n", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,"Usage: %s number\n",argv[0]); return 1; &#125; double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout,"The square root of %g is %g\n", inputValue, outputValue); return 0;&#125; 完整源代码以及CMakeLists.txt文件：Step1二. 添加库如何添加一个库到项目中呢？我们在一些可以跨平台的项目中会看到同一个功能的库会在不同的头文件中，如何在不变代码的情况下，灵活的可选择的添加库呢？ 示例目录结构123456789101112131415./Tutorial | +--- CMakeLists.txt | +--- TutorialConfig.h.in | +--- tutorial.cpp | +---MathFunctions/ 库所在的目录 | +--- CMakeLists.txt | +--- MathFunctions.h | +--- mysqrt.cpp 第一步 在库所在的子目录中添加CMakeLists.txt，内容如下：12# 生成一个静态链接库add_library(MathFunctions mysqrt.cxx) 第二步 在源代码所在的目录的CMakeLists.txt需要添加库目录，添加include目录（相当于-I），添加库链接(相当于-l)123456789# 添加库所在的目录到includeinclude_directories ("$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions")# 添加库所做在的子目录add_subdirectory (MathFunctions)# 添加可执行文件add_executable (Tutorial tutorial.cxx)# 添加链接库target_link_libraries (Tutorial MathFunctions) 以上，我们已经实现了添加库对应的CMakeLists的实现，接下来实现如何可选择的添加库和链接 第三步 我们需要定义一个宏，类似于添加版本号那样的实现 在TutorialConfig.h.in中添加#cmakedefine USE_MYMATH 在源代码目录的CMakeLists.txt中添加一行 option (USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)，对应是否设置USE_MYMATH, ON表示开启 同时在该CMakeLists.txt中针对USE_MYMATH加上if逻辑来指定添加库和链接 源代码中可以使用ifdef USE_MYMATH来选择代码实现 完整CMakeLists.txt文件1234567891011121314151617181920212223242526272829cmake_minimum_required (VERSION 2.6)project (Tutorial)# 版本号set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0)# 宏USE_MYMATH开启option(USE_MYMATH "Use tutorial provided math implementation" ON)configure_file ( "$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in" "$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h" )# 将TutorialConfig.h的目录添加到includeinclude_directories ("$&#123;PROJECT_BINARY_DIR&#125;")# 根据USE_MYMATH来判断是否添加依赖库if (USE_MYMATH) include_directories ("$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions") add_subdirectory (MathFunctions) set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif ()# 可执行文件add_executable (Tutorial tutorial.cxx)# 库链接到可执行文件target_link_libraries (Tutorial $&#123;EXTRA_LIBS&#125;) 对应源代码：123456789101112131415161718192021222324252627282930313233// A simple program that computes the square root of a number#include "TutorialConfig.h"#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#ifdef USE_MYMATH#include "MathFunctions.h"#endifint main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; fprintf(stdout, "%s Version %d.%d\n", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout, "Usage: %s number\n", argv[0]); return 1; &#125; double inputValue = atof(argv[1]); double outputValue = 0; if (inputValue &gt;= 0) &#123;#ifdef USE_MYMATH outputValue = mysqrt(inputValue);#else outputValue = sqrt(inputValue);#endif &#125; fprintf(stdout, "The square root of %g is %g\n", inputValue, outputValue); return 0;&#125; 完整源代码以及CMakeLists.txt文件：Step2三. 安装与测试cmake可以指定安装规则，实现将可执行文件，库文件，和头文件。最后可以通过make install来安装到指定目录，需要在CMakeLists.txt文件添加如下内容 12345678910# 可自定义安装目录，默认为/usr/local/set(CMAKE_INSTALL_PREFIX /home/work/)# 添加安装库和头文件install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)# 添加安装可执行文件install (TARGETS Tutorial DESTINATION bin)install (FILES "$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h" DESTINATION include) cmake也可以支持测试，比如有些项目可以通过make test来验证，这里不做介绍，可官方教程或者下面代码链接 完整源代码以及CMakeLists.txt文件：Step3四. 构建安装包当我们想发布项目提供别人使用，就需要项目打包（二进制安装包和源码安装包）。cmake中提供了cpack的工具，专门用来打包。在源码目录的CMakeLists.txt文件尾部添加如下内容 12345678# 构建一个cpack的安装包# 导入InstallRequiredSystemLibraries模块为了导入当前项目所需要的运行时库include (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE "$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt")set (CPACK_PACKAGE_VERSION_MAJOR "$&#123;Tutorial_VERSION_MAJOR&#125;")set (CPACK_PACKAGE_VERSION_MINOR "$&#123;Tutorial_VERSION_MINOR&#125;")include (CPack) 生成二进制安装包 cpack --config CPackConfig.cmake 生成源码安装包 cpack --config CPackSourceConfig.cmake 完整源代码以及CMakeLists.txt文件：Step4相关链接官方教程cmake入门实战cmake下载链接]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C/C++实现函数返回字符串]]></title>
    <url>%2F2017%2F09%2F04%2FC-C-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[问题如何实现一个返回值为char*的函数1char* fun(...); 解决方法方法1：返回字符串常量返回一个指向字符串常量的指针，但是这个方法非常局限，因为字符串常量存储在全局静态区，是只读内存区，无法对它进行计算和修改123456789char* fun() &#123; return "hello world";&#125;// 或者如下方式char* fun() &#123; // 不加const_cast会有warning:warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings] char *str = const_cast&lt;char *&gt;("hello world"); return str;&#125; 方法2：使用全局申明的数组变量使用一个全局数组变量来存储，简单易用，缺点是任何人可以在任何时候都可以修改这个数组，而且函数的下一次调用会覆盖掉当前值，此外，全局数组的内存大小需要$ \geq $函数返回值所需要的内存大小12345678char g_str[100];char* fun() &#123; ... g_str[i] = ... ... return g_str;&#125; 方法3：使用静态数组static可以保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行就完成初始化，也是唯一一次初始化。只有拥有指向该数组的指针可以修改这个静态数组，函数的下一次调用会覆盖这个数组的内容（static的初始化赋值语句只会执行一次）。此外，和全局数组一样，大型缓冲区闲置不用非常浪费内存12345char* fun() &#123; static char buffer[100]; ... return buffer;&#125; 方法4：函数内部显示分配堆内存来保存返回值每次调用时都会创建新的内存，所以该函数调用不会覆盖以前的返回值。适用于多线程。缺点是程序员必须手动管理内存，不在同一代码块中malloc和free，会很容易出现内存泄露的bug12345678char* fun() &#123; char *str = (char *)malloc(100*sizeof(char)); ... return str;&#125;// 外部调用后需要释放内存char *str = fun()free(str); 方法5：调用者分配内存来保存返回值【推荐】最佳方案：调用者分配内存来保存函数的返回值，在同一个代码块中malloc和free内存，同时调用者应该设置指定缓冲区大小123456789101112char* fun(char *result, int size) &#123; ... strncpy(result, 'hello world', size); ... return result;&#125;// 外部调用char *buffer = (char *)malloc(size);fun(buffer, size);...free(buffer); 标准库中的fgets()等函数就是采用这样的方法来实现1char *fgets(char *str, int n, FILE *stream); 给出一个调用fgets()的示例程序，来自 www.cplusplus.com 1234567891011121314151617/* fgets example */#include &lt;stdio.h&gt;int main()&#123; FILE * pFile; char mystring [100]; pFile = fopen ("myfile.txt" , "r"); if (pFile == NULL) perror ("Error opening file"); else &#123; if ( fgets (mystring , 100 , pFile) != NULL ) puts (mystring); fclose (pFile); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
</search>
